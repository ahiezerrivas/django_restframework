serializers 
Serializers allow complex data such as querysets and model instances to be converted to native Python datatypes that can then be easily rendered into JSON, XML or other content types. Serializers also provide deserialization, allowing parsed data to be converted back into complex types, after first validating the incoming data.

The serializers in REST framework work very similarly to Django's Form and ModelForm classes. We provide a Serializer class which gives you a powerful, generic way to control the output of your responses, as well as a ModelSerializer class which provides a useful shortcut for creating serializers that deal with model instances and querysets


Qu√© significan *args y **kwargs como par√°metros
Entendiendo *args
En Python, el par√°metro especial *args en una funci√≥n se usa para pasar, de forma opcional, un n√∫mero variable de argumentos posicionales.

Jajaja, vaya paranoia de definici√≥n. Vamos a verla detalladamente:

Lo que realmente indica que el par√°metro es de este tipo es el s√≠mbolo ‚Äò*‚Äô, el nombre args se usa por convenci√≥n.
El par√°metro recibe los argumentos como una tupla.
Es un par√°metro opcional. Se puede invocar a la funci√≥n haciendo uso del mismo, o no.
El n√∫mero de argumentos al invocar a la funci√≥n es variable.
Son par√°metros posicionales, por lo que, a diferencia de los par√°metros con nombre, su valor depende de la posici√≥n en la que se pasen a la funci√≥n.
Pero como yo siempre digo, las cosas se ven mejor con un ejemplo:

La siguiente funci√≥n toma dos par√°metros y devuelve como resultado la suma de los mismos:

def sum(x, y):
    return x + y
Si llamamos a la funci√≥n con los valores x=2 e y=3, el resultado devuelto ser√° 5.

>>>sum(2, 3)
5
Pero, ¬øqu√© ocurre si posteriormente decidimos o nos damos cuenta de que necesitamos sumar un valor m√°s?

>>>sum(2, 3, 4)
Traceback (most recent call last):
  File "<input>", line 1, in <module>
TypeError: sum() takes 2 positional arguments but 3 were given
Obviamente, estaba claro de que la llamada a la funci√≥n iba a fallar.

¬øC√≥mo podemos solucionar este problema? Pues una opci√≥n ser√≠a a√±adir m√°s par√°metros a la funci√≥n, pero ¬øcu√°ntos?

La mejor soluci√≥n, la m√°s elegante y la m√°s al estilo Python es hacer uso de *args en la definici√≥n de esta funci√≥n. De este modo, podemos pasar tantos argumentos como queramos. Pero antes de esto, tenemos que reimplementar nuestra funci√≥n sum:

def sum(*args):
    value = 0
    for n in args:
        value += n
    return value
Con esta nueva implementaci√≥n, podemos llamar a la funci√≥n con cualquier n√∫mero variable de valores:

>>>sum()
0
>>>sum(2, 3)
5
>>>sum(2, 3, 4)
9
>>>sum(2, 3, 4, 6, 9, 21)
45
Entendiendo **kwargs
Veamos ahora el uso de **kwargs como par√°metro.

En Python, el par√°metro especial **kwargs en una funci√≥n se usa para pasar, de forma opcional, un n√∫mero variable de argumentos con nombre.

Las principales diferencias con respecto *args son:

Lo que realmente indica que el par√°metro es de este tipo es el s√≠mbolo ‚Äò**‚Äô, el nombre kwargs se usa por convenci√≥n.
El par√°metro recibe los argumentos como un diccionario.
Al tratarse de un diccionario, el orden de los par√°metros no importa. Los par√°metros se asocian en funci√≥n de las claves del diccionario.
¬øCu√°ndo es √∫til su uso?

Imaginemos que queremos implementar una funci√≥n filter que nos devuelva una consulta SQL de una tabla clientes que tiene los siguientes campos: nombre, apellidos, fecha_alta, ciudad, provincia, tipo y fecha_nacimiento.

Una primera aproximaci√≥n podr√≠a ser la siguiente:

def filter(ciudad, provincia, fecha_alta):
    return "SELECT * FROM clientes WHERE ciudad='{}' AND provincia='{}' AND fecha_alta={};".format(ciudad, provincia, fecha_alta)
No es una funci√≥n para sentirse muy contento üòñ Entre los diferentes problemas que pueden surgir tenemos:

Si queremos filtrar por un nuevo par√°metro, hay que cambiar la definici√≥n de la funci√≥n as√≠ como la implementaci√≥n.
Los par√°metros son todos obligatorios.
Si queremos consultar otro tipo de clientes manteniendo esta consulta, debemos crear una nueva funci√≥n.
La soluci√≥n a todos estos problemas est√° en hacer uso del par√°metro **kwargs. Veamos c√≥mo ser√≠a la nueva funci√≥n filter usando **kwargs:

def filter(**kwargs):
    query = "SELECT * FROM clientes"
    i = 0
    for key, value in kwargs.items():
        if i == 0:
            query += " WHERE "
        else:
            query += " AND "
        query += "{}='{}'".format(key, value)
        i += 1
    query += ";"
    return query
Con esta nueva implementaci√≥n hemos resuelto todos nuestros problemas como aut√©nticos pythonistas üòÑüêç

A continuaci√≥n podemos ver c√≥mo se comporta la nueva funci√≥n filter:

>>>filter()
SELECT * FROM clientes;
>>>filter(ciudad="Madrid")
SELECT * FROM clientes WHERE ciudad='Madrid';
>>>filter(ciudad="Madrid", fecha_alta="25-10-2018")
SELECT * FROM clientes WHERE ciudad='Madrid' AND fecha_alta='25-10-2018';
Hasta aqu√≠ hemos visto qu√© significan los par√°metros *args y **kwargs en una funci√≥n